package adk.selectorswitch;

import android.content.Context;
import android.graphics.Paint;

import java.util.List;

/**
 * SelectorDial describes the dial used in a selector switch. This dial has different modes
 * that can be selected by the user. This class stores the structural properties of the dial.
 * Every selector switch has an instance of selector dial and every time the view of the switch
 * is drawn onto the canvas, these structural details are queried from the selector dial.
 * <p>
 * The structure of the dial is described
 * {@see <a href="https://www.github.com/adk96r/Selector-Switch-UI-Component">here</a>}.
 * <p>
 * The details stored include the radius of the dial, the number of modes in the
 * dial, the color and paint used to draw each one of them, the angle at which each mode
 * starts in the dial and the angle between two modes.
 */

class SelectorDial {

    /**
     * Dial has a default radius of {@value #DIAL_RADIUS_DP} DP units.
     */
    private static final int DIAL_RADIUS_DP = 14;

    /**
     * Dial should have a minimum of {@value #MIN_MODES}.
     */
    private static final int MIN_MODES = 1;

    /**
     * Dial can have a maximum of {@value #MAX_MODES}.
     */
    private static final int MAX_MODES = 8;

    /**
     * Context used to extract the device's screen density for converting DP units into
     * pixels.
     */
    private Context context;

    /**
     * Stores the density of the device's screen.
     */
    private float screenDensity;

    /**
     * Stores the number of modes in the dial.
     *
     * @see #MIN_MODES
     * @see #MAX_MODES
     */
    private int dialModeCount;

    /**
     * Stores the radius of the dial in pixels.
     *
     * @see #DIAL_RADIUS_DP
     */
    private int dialRadius;

    /**
     * Stores the angle between two successive modes in the dial.
     *
     * @see SelectorUtil#getSweepingAngle(int)
     */
    private Float modeSweepingAngle;

    /**
     * Stores the starting angle for each mode in the dial.
     *
     * @see SelectorUtil#generateStartingAngles(int, float)
     */
    private List<Float> modeStartingAngles;

    /**
     * Stores the paints used to draw each mode in the dial.
     *
     * @see SelectorUtil#generateDialPaints(int, List)
     */
    private List<Paint> dialPaints;

    /**
     * Stores the colors for each mode in the dial.
     *
     * @see SelectorUtil#generateBlendingColors(int, int, int)
     */
    private List<Integer> dialColors;

    /**
     * Constructs a selector dial and initialises its properties based on the given values.
     * <p>
     * The properties initialised are :
     * <ul>
     * <li>{@link #dialModeCount}</li>
     * <li>{@link #dialRadius}</li>
     * <li>{@link #modeSweepingAngle}</li>
     * <li>{@link #modeStartingAngles}</li>
     * <li>{@link #dialColors}: List generated from the int[] dialColors arg .</li>
     * <li>{@link #dialPaints}: List generated from the {@link #dialColors} .</li>
     * </ul>
     *
     * @param context       <tt>Context</tt>: A context used to calculate the density
     *                      of the screen for calculating dial's radius in pixels from DPs.
     * @param dialModeCount <tt>int</tt>: The total number of modes in the dial, which should
     *                      be at least {@link #MIN_MODES} and at most {@link #MAX_MODES}.
     * @param dialColors    <tt>int[]</tt>: Array specifies the color used for each mode in
     *                      the dial.
     * @throws IllegalSelectorException If dialModeCount is less than {@link #MIN_MODES} or
     *                                  greater than {@link #MAX_MODES}.
     * @see SelectorUtil
     * @see SelectorUtil#arrayToList(int[])
     * @see SelectorUtil#generateDialPaints(int, List)
     * @see SelectorUtil#getSweepingAngle(int)
     * @see SelectorUtil#generateStartingAngles(int, float)
     */
    SelectorDial(Context context, int dialModeCount, List<Integer> dialColors)
            throws IllegalSelectorException {

        this.screenDensity = context.getTheme().getResources().getDisplayMetrics().density;
        initialiseDial(dialModeCount);
        this.dialColors = dialColors;
        this.dialPaints = SelectorUtil.generateDialPaints(dialModeCount, this.dialColors);
    }

    /**
     * Similar to the first constructor; except here only the starting and the ending colors
     * are needed. The remaining colors for the intermediate modes are generated by blending
     * these 2 colors gradually from the starting to the ending color. This blending is done
     * using the {@link SelectorUtil#generateBlendingColors(int, int, int)} static method.
     *
     * @param context       <tt>Context</tt>: The context used to get the screen's density.
     * @param dialModeCount <tt>int</tt>: The number of modes in the dial.
     * @param startingColor <tt>int</tt>: The first mode's or the starting mode's color
     *                      in the dial.
     * @param endingColor   <tt>int</tt>: The last mode's or the ending mode's color in
     *                      the dial.
     * @throws IllegalSelectorException
     * @see SelectorUtil
     * @see SelectorUtil#arrayToList(int[])
     * @see SelectorUtil#generateBlendingColors(int, int, int)
     * @see SelectorUtil#getSweepingAngle(int)
     * @see SelectorUtil#generateStartingAngles(int, float)
     */
    public SelectorDial(Context context, int dialModeCount, int startingColor, int endingColor)
            throws IllegalSelectorException {

        this.screenDensity = context.getTheme().getResources().getDisplayMetrics().density;
        initialiseDial(dialModeCount);
        this.dialColors = SelectorUtil.generateBlendingColors(dialModeCount, startingColor, endingColor);
        this.dialPaints = SelectorUtil.generateDialPaints(dialModeCount, this.dialColors);
    }

    /**
     * Initialises the {@link #dialModeCount}, {@link #dialRadius}, {@link #modeSweepingAngle}
     * and {@link #modeStartingAngles} for the various modes in the dial.
     *
     * @param dialModeCount The number of modes in the selector switch's dial.
     * @throws IllegalSelectorException If the number of modes is less than {@link #MIN_MODES} or
     *                                  more than {@link #MAX_MODES}.
     * @see SelectorUtil#getSweepingAngle(int)
     * @see SelectorUtil#generateStartingAngles(int, float)
     * @see SelectorUtil#getPixelsFromDips(int, float)
     */
    private void initialiseDial(int dialModeCount) throws IllegalSelectorException {

        if (dialModeCount < MIN_MODES) {
            throw new IllegalSelectorException("Not enough modes in the selector dial!");
        } else if (dialModeCount > MAX_MODES) {
            throw new IllegalSelectorException("Too many modes to accommodate in the selector dial!");
        }

        this.dialModeCount = dialModeCount;
        this.dialRadius = SelectorUtil.getPixelsFromDips(DIAL_RADIUS_DP, screenDensity);
        this.modeSweepingAngle = SelectorUtil.getSweepingAngle(this.dialModeCount);
        this.modeStartingAngles = SelectorUtil.generateStartingAngles(this.dialModeCount,
                this.modeSweepingAngle);
    }

    /**
     * Returns {@link #dialRadius} : the radius of the dial.
     *
     * @return dialRadius
     */
    int getDialRadius() {
        return this.dialRadius;
    }

    /**
     * Returns {@link #dialColors} : the list of colors for the modes of the dial.
     *
     * @return dialColors   List of colors
     */
    List<Integer> getDialColors() {
        return this.dialColors;
    }

    /**
     * Updates the {@link #dialColors} of the dial and re-initialises {@link #dialPaints}
     * based on the new list of colors.
     *
     * @param dialColors New list of colors (Integers).
     * @see SelectorUtil#generateDialPaints(int, List)
     */
    void setDialColors(List<Integer> dialColors) {
        this.dialColors = dialColors;
        this.dialPaints = SelectorUtil.generateDialPaints(dialModeCount, dialColors);
    }

    /**
     * Updates the {@link #dialColors} of the dial and re-initialises {@link #dialPaints}
     * using the list of blended colors generated from the given two colors.
     *
     * @param startingColor Color to start blending from.
     * @param endingColor   Color to end blending at.
     * @see SelectorUtil#generateBlendingColors(int, int, int)
     * @see SelectorUtil#generateDialPaints(int, List)
     */
    void setDialColors(int startingColor, int endingColor) {
        this.dialColors = SelectorUtil.generateBlendingColors(dialModeCount, startingColor,
                endingColor);
        this.dialPaints = SelectorUtil.generateDialPaints(dialModeCount, dialColors);
    }

    /**
     * Updates the color for a specified mode in the dial and re co
     *
     * @param index Index of the mode.
     * @param color New color for the mode.
     * @see SelectorUtil#generateDialPaint(int)
     */
    void setModeColor(int index, int color) {
        this.dialColors.set(index, color);
        this.dialPaints.set(index, SelectorUtil.generateDialPaint(color));
    }

    /**
     * Returns {@link #dialModeCount} : the number of modes in the dial.
     *
     * @return {@link #dialModeCount}
     */
    int getDialModeCount() {
        return dialModeCount;
    }

    /**
     * Updates the {@link #dialModeCount} of the dial. If the new count is more than the
     * current count, current starting and ending colors are used to generate the a list
     * of blending colors to for the new set of intermediate modes. If the new count is
     * less or equal to than the current count, the current {@link #dialColors} list is
     * replaced by its subset of a size equal to the new count. The method also updates
     * the {@link #dialPaints}, {@link #modeSweepingAngle} and {@link #modeStartingAngles}
     * based on the new number of modes.
     * <p>
     *
     * @param dialModeCount New number of modes.
     * @throws IllegalSelectorException If the new number of states less than {@link #MIN_MODES}
     *                                  or greater than {@link #MAX_MODES}.
     * @see SelectorUtil#generateBlendingColors(int, int, int)
     * @see SelectorUtil#getSweepingAngle(int)
     * @see SelectorUtil#generateStartingAngles(int, float)
     */
    void setDialModeCount(int dialModeCount) throws IllegalSelectorException {

        // Check the validity of the new count.
        if (dialModeCount < MIN_MODES) {
            throw new IllegalSelectorException("Too few modes to select!");
        } else if (dialModeCount > MAX_MODES) {
            throw new IllegalSelectorException("Too many modes to accommodate!");
        }

        if (this.dialModeCount < dialModeCount) {   // Blend.
            this.dialColors = SelectorUtil.generateBlendingColors(dialModeCount,
                    this.dialColors.get(0), this.dialColors.get(this.dialColors.size() - 1));
        } else {                                    // Slice.
            this.dialColors = dialColors.subList(0, dialModeCount);
        }

        // Update the dial count and angles.
        this.dialModeCount = dialModeCount;
        this.modeSweepingAngle = SelectorUtil.getSweepingAngle(dialModeCount);
        this.modeStartingAngles = SelectorUtil.generateStartingAngles(dialModeCount,
                modeSweepingAngle);
    }

    /**
     * Returns the angle between two successive modes in the dial.
     *
     * @return {@link #modeSweepingAngle}
     */
    Float getModeSweepingAngle() {
        return modeSweepingAngle;
    }

    /**
     * Returns the list of starting angles for the modes in the dial.
     *
     * @return {@link #modeStartingAngles}
     */
    public List<Float> getModeStartingAngles() {
        return modeStartingAngles;
    }

    /**
     * Returns the starting angle of a particular mode in the dial. Useful while
     * drawing the dial onto the switch's canvas.
     *
     * @param mode Index of the mode.
     * @return startingAngle The starting angle for the mode at the given index.
     */
    Float getModeStartingAngle(int mode) {
        if (mode < 0) mode = 0;
        if (mode >= dialModeCount) mode = dialModeCount - 1;
        return modeStartingAngles.get(mode);
    }

    /**
     * Returns the list of paints for each mode in the dial.
     *
     * @return {@link #dialPaints}
     */
    public List<Paint> getDialPaints() {
        return dialPaints;
    }

    /**
     * Returns the Paint instance for a particular mode in the dial.
     *
     * @param mode Index of the mode.
     * @return paint Paint of the mode at the given index.
     */
    Paint getDialPaintForMode(int mode) {
        if (mode < 0) mode = 0;
        if (mode >= dialModeCount) mode = dialModeCount - 1;
        return dialPaints.get(mode);
    }

}
